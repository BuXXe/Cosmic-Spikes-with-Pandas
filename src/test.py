""" test.py --

 UI generated by GUI Builder Build 146 on 2015-12-23 00:05:33 from:
    E:/Users/BuXXe/Downloads/test.ui
 This file is auto-generated.  Only the code within
    '# BEGIN USER CODE (global|class)'
    '# END USER CODE (global|class)'
 and code inside the callback subroutines will be round-tripped.
 The 'main' function is reserved.
"""
import Tix
from SplashScreen import SplashScreen
from Tkinter import *
from test_ui import Test
import tkFileDialog
import pandas as pd
import os
from DataSet import DataSet
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import matplotlib
import TrendlineUnspiking
from ManualUnspiker import manualUnspiker
matplotlib.use('TkAgg')
import ImportHelpers

# TODO: initial directory for dialogs
# TODO: better integration of unpsike parameters. setting parameters after compeltion is dirty
# TODO: problem with focus / selection of listbox lost when clicking somewhere else


# BEGIN USER CODE global
pd.set_option('display.mpl_style', 'default') # Make the graphs a bit prettier
# text widgets, if disabled, do not allow to select / set focus in order to ctrl+c
# this helps:
# t.bind("<1>", lambda event: t.focus_set())

# This list contains the current items 
# the list is corresponding to the list box(!)
# each entry contains:
# Object with Original Data, Processed Data (if already existent) and their parameters,
# additional info about the original data
activeDataList = []

# END USER CODE global
figu = None
canvas =None


class CustomTest(Test):
    pass

    # BEGIN CALLBACK CODE
    # ONLY EDIT CODE INSIDE THE def FUNCTIONS.

    # Use text_field as read-only
    # use states to create read only access
    # scroll to end of debug_text
    def write_to_Debug(self, message, tags):
        self.debug_text.config(state=NORMAL)
        self.debug_text.insert(END,message, tags)
        self.debug_text.config(state=DISABLED)
        self.debug_text.see("end")
        
    # add_button_command --
    #
    # Callback to handle add_button widget option -command
    def add_button_command(self, *args):
        # Open File / Files      
        filetypes  = [('text/csv files', '*.csv;*.txt'), ('all files', '.*')]
        file_paths = tkFileDialog.askopenfilenames(filetypes = filetypes)
        
        # for each selected file do 
        for filepath in file_paths:
            data = None
            try:
                # differentiate if original spectroscopy txt or already processed csv
                # use file ending as criterion
                if os.path.splitext(filepath)[1].lower() == ".txt":              
                    data = ImportHelpers.convertTxtToPandaFrame(filepath)
                elif os.path.splitext(filepath)[1].lower() == ".csv":
                    data = ImportHelpers.convertCsvToPandaFrame(filepath)

                if data is None:
                    raise Exception("Import problem")
                
                # append to data array and UI list
                activeDataList.append(DataSet(data , os.path.split(filepath)[1]))
                self.item_list.insert(END,os.path.split(filepath)[1])
            except :
                self.write_to_Debug("[ERROR]: Processing of file: "+filepath+" failed\n", ("e"))


    # remove_button_command --
    #
    # Callback to handle remove_button widget option -command
    def remove_button_command(self, *args):
        if self.item_list.curselection():
            del activeDataList[self.item_list.curselection()[0]]
            self.item_list.delete(self.item_list.curselection()[0])
            if self.item_list.size()== 0:
                # clear the text boxes
                self._text_3.config(state=NORMAL)
                self._text_3.delete(1.0, END)
                self._text_3.config(state=DISABLED)
                self._text_2.config(state=NORMAL)
                self._text_2.delete(1.0, END)
                self._text_2.config(state=DISABLED)
                self.createPreview()

            else:
                # update and set anchor
                self.item_list.select_set(0)
                # update textboxes
                self.updateTextBoxes()
                self.createPreview()

    
    # update parameter boxes and preview canvas
    def immediately(self,e):
        self.updateTextBoxes()
        self.createPreview()

    # put Dataset data in property frames    
    def updateTextBoxes(self):
        if self.item_list.curselection():
            self._text_3.config(state=NORMAL)
            self._text_3.delete(1.0, END)
            self._text_3.insert(END,activeDataList[self.item_list.curselection()[0]].getDescription())
            self._text_3.config(state=DISABLED)
            #self._text_2.config(state=NORMAL)
            #self._text_2.delete(1.0, END)
            #self._text_2.insert(END,activeDataList[self.item_list.curselection()[0]].getDescriptionProcessedData())
            #self._text_2.config(state=DISABLED)

    # get the preview for the selected graph and put it into preview canvas
    def createPreview(self):
        global figu
        global canvas
        
        # initial creation of preview window
        if figu == None:
            figu = Figure(frameon=False,figsize=(1,1), dpi=100)
            
            figu.clf()
            a = figu.add_subplot(111)
            
            if self.item_list.curselection():
                activeDataList[self.item_list.curselection()[0]].showGraphOriginal(ax=a)
            
            canvas = FigureCanvasTkAgg(figu, self._frame_4)
            
            canvas.get_tk_widget().grid(
                in_    = self._frame_4,
                column = 1,
                row    = 15,
                columnspan = 2,
                ipadx = 0,
                ipady = 0,
                padx = 0,
                pady = 0,
                rowspan = 1,
                sticky = "news")
        else:
            figu.clf()
            a = figu.add_subplot(111)
            
            if self.item_list.curselection():
                activeDataList[self.item_list.curselection()[0]].showGraphOriginal(ax=a)
            canvas.show()    
            canvas.draw()

   
    ####
    # GUI Buttons / Controls
    # - Export as CSV (Processed Set) (NON-Interpolated)
    # - Export mean as CSV (Processed Set) (Interpolated)
    #
    # - Revert one step (History)
    # - Reset to Original
    # - Despike (cascaded menu for multiple methods? first approach: Trendline only) 
    #     -> different Parameter sets need different UI
    #     - Checkbox -> Debug Mode (Dry Run)
    #
    # - Show Original
    # - Show Processed
    # - Show Mean (Processed)
    ####
          
          
    ####
    #
    # EXPORT-FUNCTIONS
    #
    ####
                 
    # export_csv_button_command --
    #
    # Callback to handle export_csv_button widget option -command
    def export_csv_button_command(self, *args):
        if self.item_list.curselection():
            try:
                filetypes  = [('all files', '.*'), ('text files', '.txt'), ('csv files', '.csv')]
                filepath = tkFileDialog.asksaveasfilename(filetypes=filetypes,initialfile ="us"+activeDataList[self.item_list.curselection()[0]].filename.replace(".txt",".csv") )
                if filepath =="":
                    return
                
                activeDataList[self.item_list.curselection()[0]].exportAsCSV(filepath)
                self.write_to_Debug("[INFO]: Unpsiked Data Set: "+self.item_list.get(self.item_list.curselection()[0]) +" exported as CSV to "+filepath+"\n",None)
            except:
                self.write_to_Debug("[ERROR]: There was an error exporting DataSet\n", ("e"))

    # export_mean_button_command --
    #
    # Callback to handle export_csv_button widget option -command
    def export_mean_button_command(self, *args):
        if self.item_list.curselection():
            try:
                filetypes  = [('all files', '.*'), ('text files', '.txt'), ('csv files', '.csv')]
                filepath = tkFileDialog.asksaveasfilename(filetypes=filetypes,initialfile ="usmean"+activeDataList[self.item_list.curselection()[0]].filename.replace(".txt",".csv"))
                if filepath =="":
                    return
                
                activeDataList[self.item_list.curselection()[0]].exportMeanAsCSV(filepath)
                self.write_to_Debug("[INFO]: Unspiked Mean of Data Set: "+self.item_list.get(self.item_list.curselection()[0]) +" exported as CSV to "+filepath+"\n",None)
            except:
                self.write_to_Debug("[ERROR]: There was an error exporting DataSet\n", ("e"))


    ####
    #
    # DATASET-MANAGEMENT-FUNCTIONS
    #
    ####
    
    #TODO: update ui afterwards
    def reset_dataset_button_command(self, *args):
        if self.item_list.curselection():
            activeDataList[self.item_list.curselection()[0]].reset()
            self.updateTextBoxes()
    
    def revert_button_command(self, *args):
        if self.item_list.curselection():
            activeDataList[self.item_list.curselection()[0]].revertstep()
            self.updateTextBoxes()


    ####
    #
    # PLOTTING-FUNCTIONS
    #
    ####


    # plot_original_button_command --
    #
    # Callback to handle plot_original_button widget option -command
    def plot_original_button_command(self, *args):
        if self.item_list.curselection():
            activeDataList[self.item_list.curselection()[0]].showGraphOriginal()
        
    # plot_unspiked_button_command --
    #
    # Callback to handle plot_unspiked_button widget option -command
    def plot_unspiked_button_command(self, *args):
        if self.item_list.curselection():
            activeDataList[self.item_list.curselection()[0]].showGraphProcessed()
    
    # plot_mean_button_command --
    #
    # Callback to handle plot_unspiked_button widget option -command
    def plot_mean_button_command(self, *args):
        if self.item_list.curselection():
            activeDataList[self.item_list.curselection()[0]].showGraphProcessedMean()
            
    ####
    #
    # UNSPIKE-FUNCTIONS
    #
    ####
    
    def dryrun_button_command(self, *args):
                # TODO Unify this to fit a more abstract unspiking library
        
        
        # check if nothing is selected, then do nothing
        if not self.item_list.curselection():
            return
        
        
        # try and get threshold / iteration count stop if not digits
        trendlinedegree = self.trendlinedegree_entry.get()
        errorfactor = self.disterrfactor_entry.get()
        minmeanerror = self.mindistmean_entry.get()
        usetrendline = bool(self.useTrendlinevariable.get())
        
        if not trendlinedegree.isdigit():
            self.write_to_Debug("[ERROR]: The trendline degree variable is not a valid number\n", ("e"))
            return

        if not errorfactor.isdigit():
            self.write_to_Debug("[ERROR]: The error factor variable is not a valid number\n", ("e"))
            return
        
        if not minmeanerror.isdigit():
            self.write_to_Debug("[ERROR]: The min dist mean variable is not a valid number\n", ("e"))
            return
        
        # Unspike with library
        # directly works with dataset structure -> libary sets values in dataset directly
        
        TrendlineUnspiking.unspike(activeDataList[self.item_list.curselection()[0]], usetrendline, trendlinedegree, errorfactor, minmeanerror, True)
        
    

    def manual_unspiker_button_command(self, *args):
        # check if nothing is selected, then do nothing
        if not self.item_list.curselection():
            return        
        
        activeDataList[self.item_list.curselection()[0]].manualUnspike()
        
        
        return
    
    
    # run_unspike_button_command --
    #
    # Callback to handle run_unspike_button widget option -command
    def run_unspike_button_command(self, *args):
        # TODO Unify this to fit a more abstract unspiking library
        
        
        # check if nothing is selected, then do nothing
        if not self.item_list.curselection():
            return
        
        
        # try and get threshold / iteration count stop if not digits
        trendlinedegree = self.trendlinedegree_entry.get()
        errorfactor = self.disterrfactor_entry.get()
        minmeanerror = self.mindistmean_entry.get()
        usetrendline = bool(self.useTrendlinevariable.get())
        
        if not trendlinedegree.isdigit():
            self.write_to_Debug("[ERROR]: The trendline degree variable is not a valid number\n", ("e"))
            return

        if not errorfactor.isdigit():
            self.write_to_Debug("[ERROR]: The error factor variable is not a valid number\n", ("e"))
            return
        
        if not minmeanerror.isdigit():
            self.write_to_Debug("[ERROR]: The min dist mean variable is not a valid number\n", ("e"))
            return
        
        # Unspike with library
        # directly works with dataset structure -> libary sets values in dataset directly
        
        TrendlineUnspiking.unspike(activeDataList[self.item_list.curselection()[0]], usetrendline, trendlinedegree, errorfactor, minmeanerror, False)
        self.updateTextBoxes()

        
        # Unspiking starts here
        # activeDataList[self.item_list.curselection()[0]].initProcessedDataWithOriginal()
                
        #for x in xrange(0,int(iterations)):
        #    self.write_to_Debug("[INFO]: Computing iteration "+str(x+1)+" for data set.\n",None)
        #    global root
        #    root.update()
        #    
        #    #hasChanged = activeDataList[self.item_list.curselection()[0]].errorcorrectdiff( int(threshold),True)
        #    hasChanged = activeDataList[self.item_list.curselection()[0]].sophisticatedErrorCorrection( int(threshold))
        #    
        #    # in case we reach a stagnation, stop processing
        #    if hasChanged==False:
        #        self.write_to_Debug("[INFO]: No more changes in iteration: "+str(x+1)+". Processing stopped\n",None)
        #        break
        #self.write_to_Debug("[INFO]: Computations completed\n",None)

        ## this sets the computation parameters in the dataset and visualizes them in the GUI
        #activeDataList[self.item_list.curselection()[0]].setProcessingParameters(int(iterations),int(threshold))
        #self.updateTextBoxes()
        ## Unspiking ends here
        
        

        
        


    # END CALLBACK CODE



root = None
def main():
    # Standalone Code Initialization
    # DO NOT EDIT
    
    try: userinit()
    except NameError: pass
    global root
        
    root = Tix.Tk( )
    
    with SplashScreen( root, 'Pandas.gif', 3.0 ):
        demo = CustomTest(root)
        root.title('Unspike with Pandas')
        root.iconbitmap("Panda.ico")
        try: run()
        except NameError: pass
        root.protocol('WM_DELETE_WINDOW', root.destroy)
    
    root.mainloop( )
if __name__ == '__main__': main()
