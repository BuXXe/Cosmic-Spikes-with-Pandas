""" test.py --

 UI generated by GUI Builder Build 146 on 2015-12-23 00:05:33 from:
    E:/Users/BuXXe/Downloads/test.ui
 This file is auto-generated.  Only the code within
    '# BEGIN USER CODE (global|class)'
    '# END USER CODE (global|class)'
 and code inside the callback subroutines will be round-tripped.
 The 'main' function is reserved.
"""

from Tkinter import *
from test_ui import Test
import tkFileDialog
import pandas as pd
import os
from DataSet import DataSet
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import matplotlib
matplotlib.use('TkAgg')


# TODO: better integration of unpsike parameters. setting parameters after compeltion is dirty
# TODO: problem with focus / selection of listbox lost when clicking somewhere else

# BEGIN USER CODE global
pd.set_option('display.mpl_style', 'default') # Make the graphs a bit prettier
# text widgets, if disabled, do not allow to select / set focus in order to ctrl+c
# this helps:
# t.bind("<1>", lambda event: t.focus_set())

# This list contains the current items 
# the list is corresponding to the list box(!)
# each entry contains:
# Object with Original Data, Processed Data (if already existent) and their parameters,
# additional info about the original data
activeDataList = []

# END USER CODE global
figu = None
canvas =None
class CustomTest(Test):
    pass

    # BEGIN CALLBACK CODE
    # ONLY EDIT CODE INSIDE THE def FUNCTIONS.

    def write_to_Debug(self, message, tags):
        self.debug_text.config(state=NORMAL)
        self.debug_text.insert(END,message, tags)
        self.debug_text.config(state=DISABLED)
        self.debug_text.see("end")
        
    # add_button_command --
    #
    # Callback to handle add_button widget option -command
    def add_button_command(self, *args):
        file_path = tkFileDialog.askopenfilenames()
        for filepath in file_path:
            try:
                data = convertTxtToPandaFrame(filepath)
                activeDataList.append(DataSet(data,os.path.split(filepath)[1]))
                self.item_list.insert(END,os.path.split(filepath)[1])
            except:
                self.write_to_Debug("[ERROR]: Processing of file: "+filepath+" failed\n", ("e"))

    # export_csv_button_command --
    #
    # Callback to handle export_csv_button widget option -command
    def export_csv_button_command(self, *args):
        if self.item_list.curselection():
            try:
                filetypes  = [('all files', '.*'), ('text files', '.txt'), ('csv files', '.csv')]
                filepath = tkFileDialog.asksaveasfilename(filetypes=filetypes,initialfile ="us"+activeDataList[self.item_list.curselection()[0]].filename.replace(".txt",".csv") )
                if filepath =="":
                    return
                
                activeDataList[self.item_list.curselection()[0]].exportAsCSV(filepath)
                self.write_to_Debug("[INFO]: Data Set: "+self.item_list.get(self.item_list.curselection()[0]) +" exported as CSV to "+filepath+"\n",None)
            except:
                self.write_to_Debug("[ERROR]: There was an error exporting DataSet\n", ("e"))

    # export_mean_button_command --
    #
    # Callback to handle export_csv_button widget option -command
    def export_mean_button_command(self, *args):
        if self.item_list.curselection():
            try:
                filetypes  = [('all files', '.*'), ('text files', '.txt'), ('csv files', '.csv')]

                filepath = tkFileDialog.asksaveasfilename(filetypes=filetypes,initialfile ="usmean"+activeDataList[self.item_list.curselection()[0]].filename.replace(".txt",".csv"))
                if filepath =="":
                    return
                
                activeDataList[self.item_list.curselection()[0]].exportMeanAsCSV(filepath)
                self.write_to_Debug("[INFO]: Unspiked Mean of Data Set: "+self.item_list.get(self.item_list.curselection()[0]) +" exported as CSV to "+filepath+"\n",None)
            except:
                self.write_to_Debug("[ERROR]: There was an error exporting DataSet\n", ("e"))

    
    def immediately(self,e):
        self.updateTextBoxes()
        self.createPreview()

        
    def updateTextBoxes(self):
        if self.item_list.curselection():
            self._text_3.config(state=NORMAL)
            self._text_3.delete(1.0, END)
            self._text_3.insert(END,activeDataList[self.item_list.curselection()[0]].getDescriptionOriginalData())
            self._text_3.config(state=DISABLED)
            self._text_2.config(state=NORMAL)
            self._text_2.delete(1.0, END)
            self._text_2.insert(END,activeDataList[self.item_list.curselection()[0]].getDescriptionProcessedData())
            self._text_2.config(state=DISABLED)

    def createPreview(self):
        global figu
        global canvas
        if figu == None:
            figu = Figure(frameon=False,figsize=(1,1), dpi=100)
            
            figu.clf()
            a = figu.add_subplot(111)
            
            if self.item_list.curselection():
                activeDataList[self.item_list.curselection()[0]].showGraphOriginal(ax=a)
            
            canvas = FigureCanvasTkAgg(figu, self._frame_4)
            
            canvas.get_tk_widget().grid(
                in_    = self._frame_4,
                column = 1,
                row    = 6,
                columnspan = 2,
                ipadx = 0,
                ipady = 0,
                padx = 0,
                pady = 0,
                rowspan = 1,
                sticky = "news")
        else:
            figu.clf()
            a = figu.add_subplot(111)
            
            if self.item_list.curselection():
                activeDataList[self.item_list.curselection()[0]].showGraphOriginal(ax=a)
            canvas.show()    
            canvas.draw()

    # plot_original_button_command --
    #
    # Callback to handle plot_original_button widget option -command
    def plot_original_button_command(self, *args):
        if self.item_list.curselection():
            activeDataList[self.item_list.curselection()[0]].showGraphOriginal()
        
    # plot_unspiked_button_command --
    #
    # Callback to handle plot_unspiked_button widget option -command
    def plot_unspiked_button_command(self, *args):
        if self.item_list.curselection():
            activeDataList[self.item_list.curselection()[0]].showGraphProcessed()
    
    # plot_mean_button_command --
    #
    # Callback to handle plot_unspiked_button widget option -command
    def plot_mean_button_command(self, *args):
        if self.item_list.curselection():
            activeDataList[self.item_list.curselection()[0]].showGraphProcessedMean()
            
    # remove_button_command --
    #
    # Callback to handle remove_button widget option -command
    def remove_button_command(self, *args):
        if self.item_list.curselection():
            del activeDataList[self.item_list.curselection()[0]]
            self.item_list.delete(self.item_list.curselection()[0])
            if self.item_list.size()== 0:
                # clear the text boxes
                self._text_3.config(state=NORMAL)
                self._text_3.delete(1.0, END)
                self._text_3.config(state=DISABLED)
                self._text_2.config(state=NORMAL)
                self._text_2.delete(1.0, END)
                self._text_2.config(state=DISABLED)
                self.createPreview()

            else:
                # update and set anchor
                self.item_list.select_set(0)
                # update textboxes
                self.updateTextBoxes()
                self.createPreview()


        

    # run_unspike_button_command --
    #
    # Callback to handle run_unspike_button widget option -command
    def run_unspike_button_command(self, *args):
        threshold = self.threshold_entry.get()
        iterations = self.iterations_entry.get()
        if not self.item_list.curselection():
            return
        
        # try and get threshold / iteration count stop if not digits
        if not iterations.isdigit():
            self.write_to_Debug("[ERROR]: The iterations variable is not a valid number\n", ("e"))
            return

        if not threshold.isdigit():
            self.write_to_Debug("[ERROR]: The threshold variable is not a valid number\n", ("e"))
            return
        
        activeDataList[self.item_list.curselection()[0]].initProcessedDataWithOriginal()
        
        
        for x in xrange(0,int(iterations)):
            self.write_to_Debug("[INFO]: Computing iteration "+str(x+1)+" for data set.\n",None)
            
            global root
            root.update()
            hasChanged = activeDataList[self.item_list.curselection()[0]].errorcorrectdiff( int(threshold),True)
            
            if hasChanged==False:
                self.write_to_Debug("[INFO]: No more changes in iteration: "+str(x+1)+". Processing stopped\n",None)
                break
        self.write_to_Debug("[INFO]: Computations completed\n",None)

        activeDataList[self.item_list.curselection()[0]].setProcessingParameters(int(iterations),int(threshold))
        self.updateTextBoxes()



    # END CALLBACK CODE

    # BEGIN USER CODE class

def convertTxtToPandaFrame(inputf):
    # Transform txt to compatible Dictionary
    # finally create dataframe from dictionary
    # need the columns as keys
    # entries as lists
    # ASSUMPTION: we always have the same x entries for all Frames!
    
    parsedObject = {}
    columns =[]
    columns.append("x")
    wholesetlistings ={}
    
    with open(inputf) as f:
        content = f.readlines()
    for line2 in content:
        
        line = line2.replace("\n","")
        if not "Frame" in line and not ";" in line and len(line)>1:
            raise Exception("Format problem")
        
        if "Frame" in line:
            columns.append(line)
            continue
        if ";" in line:
            if len(line.split(";")) != 2:
                raise Exception("wrong format")
            if line.split(";")[0] not in wholesetlistings:
                wholesetlistings[line.split(";")[0]]=[]
            wholesetlistings[line.split(";")[0]].append(float(line.split(";")[1]))
    
    if len(columns) <2:
        raise Exception("No Frames in set found")
    
    
    # create columns
    for col in columns:
        parsedObject[col]=[]     
    
    for entry in wholesetlistings:
        parsedObject["x"].append(float(entry))

        for g,i in enumerate(columns[1:]):
            parsedObject[i].append(float(wholesetlistings[entry][g]))
        
    df = pd.DataFrame(parsedObject)
    df.sort_values("x",inplace=True)
    df.set_index("x", inplace=True)
    return df

def convertTxtToCSV(inputf,outputf):
    # Transform txt to compatible csv
    head = "x;"
    wholesetlistings ={}
     
    with open(inputf) as f:
        content = f.readlines()
   
    for line2 in content:
        line = line2.replace("\n","")
        if "Frame" in line:
            head+=line+";"
            continue
        if ";" in line:
            if line.split(";")[0] not in wholesetlistings:
                wholesetlistings[line.split(";")[0]]=[]
            wholesetlistings[line.split(";")[0]].append(float(line.split(";")[1]))
  
    f = open(outputf,'w')
    # delete last ; from head and write to file
    f.write(head[:-1]+"\n")
     
    for entry in  wholesetlistings:
        f.write(entry+";")
        line =""
        for i in wholesetlistings[entry]:
            line=line+str(i)+";"
        f.write(line[:-1]+"\n")
    f.close() 
    # END USER CODE class


root = None
def main():
    # Standalone Code Initialization
    # DO NOT EDIT
    
    try: userinit()
    except NameError: pass
    global root
    root = Tk()
    demo = CustomTest(root)
    root.title('Unspike with Pandas')
    root.iconbitmap("Panda.ico")
    try: run()
    except NameError: pass
    root.protocol('WM_DELETE_WINDOW', root.destroy)
    root.mainloop()

if __name__ == '__main__': main()
