""" test.py --

 UI generated by GUI Builder Build 146 on 2015-12-23 00:05:33 from:
    E:/Users/BuXXe/Downloads/test.ui
 This file is auto-generated.  Only the code within
    '# BEGIN USER CODE (global|class)'
    '# END USER CODE (global|class)'
 and code inside the callback subroutines will be round-tripped.
 The 'main' function is reserved.
"""
from __future__ import with_statement   # <-- Python 2.5 ONLY
import Tix
import time
from Tkinter import *
from test_ui import Test
import tkFileDialog
import pandas as pd
import os
from DataSet import DataSet
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import matplotlib
matplotlib.use('TkAgg')
import ImportHelpers

# TODO: better integration of unpsike parameters. setting parameters after compeltion is dirty
# TODO: problem with focus / selection of listbox lost when clicking somewhere else

# BEGIN USER CODE global
pd.set_option('display.mpl_style', 'default') # Make the graphs a bit prettier
# text widgets, if disabled, do not allow to select / set focus in order to ctrl+c
# this helps:
# t.bind("<1>", lambda event: t.focus_set())

# This list contains the current items 
# the list is corresponding to the list box(!)
# each entry contains:
# Object with Original Data, Processed Data (if already existent) and their parameters,
# additional info about the original data
activeDataList = []

# END USER CODE global
figu = None
canvas =None
class CustomTest(Test):
    pass

    # BEGIN CALLBACK CODE
    # ONLY EDIT CODE INSIDE THE def FUNCTIONS.

    # Use text_field as read-only
    # use states to create read only access
    # scroll to end of debug_text
    def write_to_Debug(self, message, tags):
        self.debug_text.config(state=NORMAL)
        self.debug_text.insert(END,message, tags)
        self.debug_text.config(state=DISABLED)
        self.debug_text.see("end")
        
    # add_button_command --
    #
    # Callback to handle add_button widget option -command
    def add_button_command(self, *args):
        # Open File / Files      
        filetypes  = [('text/csv files', '*.csv;*.txt'), ('all files', '.*')]
        file_paths = tkFileDialog.askopenfilenames(filetypes = filetypes)
        for filepath in file_paths:
            data = None

            try:
                # differentiate if original spectroscopy txt or already processed csv
                # use file ending as criterion
                if os.path.splitext(filepath)[1].lower() == ".txt":              
                    data = ImportHelpers.convertTxtToPandaFrame(filepath)
                elif os.path.splitext(filepath)[1].lower() == ".csv":
                    data = ImportHelpers.convertCsvToPandaFrame(filepath)

                if data is None:
                    raise Exception("Import problem")
                # append to data array and UI list
                activeDataList.append(DataSet(data,os.path.split(filepath)[1]))
                self.item_list.insert(END,os.path.split(filepath)[1])
            except :
                self.write_to_Debug("[ERROR]: Processing of file: "+filepath+" failed\n", ("e"))

                
    # export_csv_button_command --
    #
    # Callback to handle export_csv_button widget option -command
    def export_csv_button_command(self, *args):
        if self.item_list.curselection():
            try:
                filetypes  = [('all files', '.*'), ('text files', '.txt'), ('csv files', '.csv')]
                filepath = tkFileDialog.asksaveasfilename(filetypes=filetypes,initialfile ="us"+activeDataList[self.item_list.curselection()[0]].filename.replace(".txt",".csv") )
                if filepath =="":
                    return
                
                activeDataList[self.item_list.curselection()[0]].exportAsCSV(filepath)
                self.write_to_Debug("[INFO]: Data Set: "+self.item_list.get(self.item_list.curselection()[0]) +" exported as CSV to "+filepath+"\n",None)
            except:
                self.write_to_Debug("[ERROR]: There was an error exporting DataSet\n", ("e"))

    # export_mean_button_command --
    #
    # Callback to handle export_csv_button widget option -command
    def export_mean_button_command(self, *args):
        if self.item_list.curselection():
            try:
                filetypes  = [('all files', '.*'), ('text files', '.txt'), ('csv files', '.csv')]

                filepath = tkFileDialog.asksaveasfilename(filetypes=filetypes,initialfile ="usmean"+activeDataList[self.item_list.curselection()[0]].filename.replace(".txt",".csv"))
                if filepath =="":
                    return
                
                activeDataList[self.item_list.curselection()[0]].exportMeanAsCSV(filepath)
                self.write_to_Debug("[INFO]: Unspiked Mean of Data Set: "+self.item_list.get(self.item_list.curselection()[0]) +" exported as CSV to "+filepath+"\n",None)
            except:
                self.write_to_Debug("[ERROR]: There was an error exporting DataSet\n", ("e"))

    
    def immediately(self,e):
        self.updateTextBoxes()
        self.createPreview()

        
    def updateTextBoxes(self):
        if self.item_list.curselection():
            self._text_3.config(state=NORMAL)
            self._text_3.delete(1.0, END)
            self._text_3.insert(END,activeDataList[self.item_list.curselection()[0]].getDescriptionOriginalData())
            self._text_3.config(state=DISABLED)
            self._text_2.config(state=NORMAL)
            self._text_2.delete(1.0, END)
            self._text_2.insert(END,activeDataList[self.item_list.curselection()[0]].getDescriptionProcessedData())
            self._text_2.config(state=DISABLED)

    def createPreview(self):
        global figu
        global canvas
        if figu == None:
            figu = Figure(frameon=False,figsize=(1,1), dpi=100)
            
            figu.clf()
            a = figu.add_subplot(111)
            
            if self.item_list.curselection():
                activeDataList[self.item_list.curselection()[0]].showGraphOriginal(ax=a)
            
            canvas = FigureCanvasTkAgg(figu, self._frame_4)
            
            canvas.get_tk_widget().grid(
                in_    = self._frame_4,
                column = 1,
                row    = 6,
                columnspan = 2,
                ipadx = 0,
                ipady = 0,
                padx = 0,
                pady = 0,
                rowspan = 1,
                sticky = "news")
        else:
            figu.clf()
            a = figu.add_subplot(111)
            
            if self.item_list.curselection():
                activeDataList[self.item_list.curselection()[0]].showGraphOriginal(ax=a)
            canvas.show()    
            canvas.draw()

    # plot_original_button_command --
    #
    # Callback to handle plot_original_button widget option -command
    def plot_original_button_command(self, *args):
        if self.item_list.curselection():
            activeDataList[self.item_list.curselection()[0]].showGraphOriginal()
        
    # plot_unspiked_button_command --
    #
    # Callback to handle plot_unspiked_button widget option -command
    def plot_unspiked_button_command(self, *args):
        if self.item_list.curselection():
            activeDataList[self.item_list.curselection()[0]].showGraphProcessed()
    
    # plot_mean_button_command --
    #
    # Callback to handle plot_unspiked_button widget option -command
    def plot_mean_button_command(self, *args):
        if self.item_list.curselection():
            activeDataList[self.item_list.curselection()[0]].showGraphProcessedMean()
            
    # remove_button_command --
    #
    # Callback to handle remove_button widget option -command
    def remove_button_command(self, *args):
        if self.item_list.curselection():
            del activeDataList[self.item_list.curselection()[0]]
            self.item_list.delete(self.item_list.curselection()[0])
            if self.item_list.size()== 0:
                # clear the text boxes
                self._text_3.config(state=NORMAL)
                self._text_3.delete(1.0, END)
                self._text_3.config(state=DISABLED)
                self._text_2.config(state=NORMAL)
                self._text_2.delete(1.0, END)
                self._text_2.config(state=DISABLED)
                self.createPreview()

            else:
                # update and set anchor
                self.item_list.select_set(0)
                # update textboxes
                self.updateTextBoxes()
                self.createPreview()


    # run_unspike_button_command --
    #
    # Callback to handle run_unspike_button widget option -command
    def run_unspike_button_command(self, *args):
        # check if nothing is selected, then do nothing
        if not self.item_list.curselection():
            return
        
        # try and get threshold / iteration count stop if not digits
        threshold = self.threshold_entry.get()
        iterations = self.iterations_entry.get()
        if not iterations.isdigit():
            self.write_to_Debug("[ERROR]: The iterations variable is not a valid number\n", ("e"))
            return

        if not threshold.isdigit():
            self.write_to_Debug("[ERROR]: The threshold variable is not a valid number\n", ("e"))
            return


        # Unspiking starts here
        activeDataList[self.item_list.curselection()[0]].initProcessedDataWithOriginal()
                
        for x in xrange(0,int(iterations)):
            self.write_to_Debug("[INFO]: Computing iteration "+str(x+1)+" for data set.\n",None)
            global root
            root.update()
            
            #hasChanged = activeDataList[self.item_list.curselection()[0]].errorcorrectdiff( int(threshold),True)
            hasChanged = activeDataList[self.item_list.curselection()[0]].sophisticatedErrorCorrection( int(threshold))
            
            # in case we reach a stagnation, stop processing
            if hasChanged==False:
                self.write_to_Debug("[INFO]: No more changes in iteration: "+str(x+1)+". Processing stopped\n",None)
                break
        self.write_to_Debug("[INFO]: Computations completed\n",None)

        # this sets the computation parameters in the dataset and visualizes them in the GUI
        activeDataList[self.item_list.curselection()[0]].setProcessingParameters(int(iterations),int(threshold))
        self.updateTextBoxes()
        # Unspiking ends here


    # END CALLBACK CODE

class SplashScreen( object ):
   def __init__( self, tkRoot, imageFilename, minSplashTime=0 ):
      self._root              = tkRoot
      self._image             = Tix.PhotoImage( file=imageFilename )
      self._splash            = None
      self._minSplashTime     = time.time() + minSplashTime
      
   def __enter__( self ):
      # Remove the app window from the display
      self._root.withdraw( )
      
      # Calculate the geometry to center the splash image
      scrnWt = self._root.winfo_screenwidth( )
      scrnHt = self._root.winfo_screenheight( )
      
      imgWt = self._image.width()
      imgHt = self._image.height()
      
      imgXPos = (scrnWt / 2) - (imgWt / 2)
      imgYPos = (scrnHt / 2) - (imgHt / 2)

      # Create the splash screen      
      self._splash = Tix.Toplevel()
      self._splash.overrideredirect(1)
      self._splash.geometry( '+%d+%d' % (imgXPos, imgYPos) )
      Tix.Label( self._splash, image=self._image, cursor='watch' ).pack( )

      # Force Tk to draw the splash screen outside of mainloop()
      self._splash.update( )
   
   def __exit__( self, exc_type, exc_value, traceback ):
      # Make sure the minimum splash time has elapsed
      timeNow = time.time()
      if timeNow < self._minSplashTime:
         time.sleep( self._minSplashTime - timeNow )
      
      # Destroy the splash window
      self._splash.destroy( )
      
      # Display the application window
      self._root.deiconify( )


#--------------------------------------------
# Now putting up splash screens is simple


root = None
def main():
    # Standalone Code Initialization
    # DO NOT EDIT
    
    try: userinit()
    except NameError: pass
    global root
    #root = Tk()
    
    
    
    
    
    
#     demo = CustomTest(root)
#     root.title('Unspike with Pandas')
#     root.iconbitmap("Panda.ico")
#     try: run()
#     except NameError: pass
#     root.protocol('WM_DELETE_WINDOW', root.destroy)
#     root.mainloop()

    root = Tix.Tk( )

    with SplashScreen( root, 'Pandas.gif', 3.0 ):
        demo = CustomTest(root)
        root.title('Unspike with Pandas')
        root.iconbitmap("Panda.ico")
        try: run()
        except NameError: pass
        root.protocol('WM_DELETE_WINDOW', root.destroy)
    
    root.mainloop( )
if __name__ == '__main__': main()
